# 设计模式

## 1. 概述

设计模式是指在软件开发中，针对特定场景下反复出现的设计问题，经过验证的解决方案。

为什么要学习设计模式

1. 特定问题的最佳方案，避免重复造轮子和出错；
2. 开发人员的标准词汇，方便和其他开发人员沟通；
3. 前人经验的积累，提高自己的捷径；

## 2. 模式列表

创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性，有5种，分别是：单例、原型、生成器、工厂方法、抽象工厂。

结构型模式将对象和类组装成较大的结构，并同时保持结构的灵活和高效，有7种，分别是：适配器、代理、装饰、组合、桥接、外观、享元。

行为型模式负责对象间的高效沟通和职责委派，有11种，分别是：职责链、策略、备忘录、模板方法、迭代器、解释器、观察者、访问者、中介者、命令、状态。

## 3. 创建型模式

单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。本质是控制实例数量。例如：Spring的Bean，Java的Runtime。

原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。本质是克隆生成对象。例如：ArrayList的clone。

生成器（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。本质是分离对象构建。例如：Java的StringBuilder、Spring的BeanDefinitionBuilder。

工厂方法（Factory Method）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法使一个类的实例化延迟到其子类。本质是延迟实现。例如：Spring中的BeanFactory或ApplicationContext。

抽象工厂（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。本质是产品族或主题的实现。

## 4. 结构型模式

适配器（Adapter）：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。本质是协调不兼容结构。例如：Spring MVC 的 HandlerAdapter。

代理模式（Proxy）：为其他对象提供一个代理以控制对这个对象的访问。本质是控制对象访问。例如：JDK动态代理Proxy、Spring AOP。

装饰模式（Decorator）：动态地给一个对象添加一些额外的职责。就扩展功能而言，装饰模式比生成子类方式更为灵活。本质是动态组合扩展功能。例如：Java的BufferedInputStream、Servlet的HttpServletRequestWrapper、Spring的BeanDefinitionDecorator。

组合模式（Composite）：将对象组合成树形结构以表示“部分–整体”的层次结构。组合模式使得客户对单个对象和组合对象的使用具有一致性。本质是处理树形结构。例如：Java中处理文件的File、处理图形界面的Swing、Awt，处理XML的JDOM、Apache POI。

桥接模式（Bridge）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。本质是处理多维度变化。例如：Java加载JDBC的DriverManager。

外观模式（Facade）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。本质是提供一致的界面。例如：Tomcat的RequestFacade。

享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。本质是对象复用。例如：Java的Integer、BigDecimal等的valueOf()。

## 5. 行为型模式

职责链模式（Chain of Responsibility）：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。本质是链式处理。例如：Servlet的Filter。

策略模式（Strategy）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。本质是算法的封装及切换。例如：Java的Comparator、Spring的ResouceLoader。

备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。本质是保存和恢复内部状态。例如：Spring Transaction。

模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。本质是定义算法框架。例如：Java的AbstractList和AbstractMap、Spring的JdbcTemplate。

迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。本质是遍历聚合对象中的元素。例如：Java的Iterator、Spring的BeanDefinitionIterator。

解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。本质是自定义语言。例如：Java正则表达式Pattern、Spring的EL表达式。

观察者模式（Observer）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。本质是触发联动。例如：Java的Observer和Observable、Spring的ApplicationEvent。

访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。本质是预留复杂对象访问通道。例如：Java的FileVisitor、Spring的BeanDefinitionVisitor。

中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。本质是协调对象间的交互。例如：java并发包Executor的execute()。

命令模式（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。本质是解耦请求发送与接收。例如：Java的Runnable、SpringMVC的HandlerMapping。

状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。本质是状态封装及转换。例如：Spring Bean Lifecycle。

## 6. 模式实现注意点

### 6.1 单例模式注意点

1. 一定要私有化构造方法；
2. 双重加锁检查（DCL，Double-Checked Locking）记得 volatile；
3. 提前初始化的实现中将实例声明为 final；
4. 如果要将单例声明为可序列化，除了使用枚举的实现外，其他实现记得添加 readResolve 方法；

### 6.2 原型模式注意点

1. 一定要 implements Cloneable，否则运行时会抛 CloneNotSupportedException 异常；
2. 一定要 Override clone，因为 Object 的 clone() 是 protected 的，只能子类和 java.lang 包访问；
3. Override clone 时，将返回值类型改为这个类的类型；
4. Object.clone() 是浅拷贝；

### 6.3 其他模式注意点

1. 代理模式有静态代理、基于JDK的动态代理、基于CGLIB的动态代理，CGLIB目前不再维护，在JDK9上可能会受到模块化的限制；
2. 生成器、迭代器、备忘录通常实现为内部类；
3. 职责链模式实现为next的方式时注意next不要形成环状；
4. 模板方法模式的方法声明要定义为 final，可以防止被子类重新实现；

## 7. 面向对象设计原则

1. 单一职责原则（Single Responsibility Principle，SRP）：

- 就一个类而言，应该仅有一个引起它变化的原因。
- 如果一个类承担的职责太多，那么就相当于把这些职责耦合在一起，任何职责的变化都可能引起其他职责的实现改变。
- 该原则的难点在于如何界定职责。

2. 开放封闭原则（Open-Closed Principle，OCP）：

- 一个类应该对扩展开放，对修改关闭。
- 实现该原则的关键是合理的抽象，分离出变化和不变的部分，为变化的部分留下扩展的空间。
- 实际开发中做到适度抽象即可，过度抽象是一种过渡设计，只会增加系统复杂性。

3. 里氏替换原则（Liskov Substitution Principle，LSP）：

- 子类型必须能够完全替换掉它的父类型，即子类和超类应该是 IS A 关系。
- 只有当子类可以替换掉超类，超类才能真正被复用，LSP 是实现继承和多态的基石。

4. 接口隔离原则（Interface Segregation Principle，ISP）：

- 不要强迫客户依赖于他们不用的方法。方法太多的接口称为胖接口，它会导致使用者之间产生有害的耦合关系，这同时也违反了 SRP 原则，解耦的方法就是分解接口。

5. 依赖倒置原则（Dependence Inversion Principle，DIP）：

- 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
- 也称好莱坞原则，描述为不要找我们，我们会联系你。
- 依赖倒置原则实际上就是面向接口编程。

6. 合成复用原则（Composite Reuse Principle, CRP）：

- 也叫组合优于继承（Composition Over Inheritance，COI）
- 优先使用对象组合或聚合，而不是通过继承来实现代码复用
- 组合是一种 HAS A 关系，是一种运行时关系，而继承是一种 IS A 关系，子类了解父类的实现，破坏了封装，而且继承是一种编译时关系，所以组合比继承具有更大的灵活性和更稳定的结构。

7. 最少知识原则（Least Knowledge Principle，LKP）：

- 也称为迪米特法则（Law of Demeter，LoD），一个对象应当对其他对象有尽可能少的了解。

8. 约定优于配置（Convention Over Configuration，COC）：

- 即基于契约设计（Design By Contract，DBC），开发前约定好一些规则，然后大部分情况下就只需要按约定编程而无须配置文件，仅需要对应用中不符约定的部分进行配置，这样虽然损失了一些的灵活性，但可以减少配置，降低复杂性和学习成本。

9. 简约（Keep it simple & stupid，KISS）：

- 大部分系统的设计越简单越好，所有不必要的复杂性都应该避免。如果一个系统非常复杂，就应该分解为多个简单的组件，做好足够的分解和抽象。

10. 避免重复（Don't Repeat Yourself，DRY）：

- 在一个系统里，对于任何数据或者变量，都应该配置在有且只有一个地方，其他的地方都应该引用这里的数据。这样，需要改动数据的时候，只需调整这一处，所有的地方就都变更过来了。

原则是用来指导而非限制设计的，设计的艺术在于权衡，所以在实际设计和开发中，应该是理解原则、应用原则，而非拘泥原则。

## 8. 设计模式分类准则

根据两条准则对模式进行分类。

第一条是目的准则，即模式是用来完成什么工作的。模式依据其目的可分为创建型（creational）、结构型（structural）和行为型（behavioral）三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。

第二条是范围准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时便确定下来了。对象模式处理对象间的关系，这些关系在运行时是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述了一组对象怎样协作完成单个对象所无法完成的任务。

工厂方法（Factory Method）、解释器（Interpreter）、模板方法（Template Method）是类设计模式，适配器（Adapter）有类适配器和对象适配器两种实现，对象适配器使用组合的方式实现，类适配器使用继承的方式实现。

